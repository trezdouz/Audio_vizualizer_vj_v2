// ============================================
// DATAMOSH EFFECT - CORRIGÉ
// S'applique UNIQUEMENT sur l'image de fond
// ============================================

class DatamoshEffect {
  PGraphics buffer;
  PImage sourceImage;
  boolean enabled;

  DatamoshEffect(int w, int h) {
    buffer = null;
    enabled = false;
    println("DatamoshEffect initialise");
  }

  // Définir l'image source à glitcher
  void setSourceImage(PImage img) {
    sourceImage = img;
  
// Buffer
if (buffer == null && img != null) {
            buffer = createGraphics(img.width, img.height);
      println("Buffer datamosh créé: " + img.width + "x" + img.height);
    }
}  
  // Applique les glitches et affiche
  void apply(float bass, float mid, float treble)  {
     println(">>> apply() appelé - enabled: " + enabled + " | sourceImage: " + (sourceImage != null) + " | buffer: " + (buffer != null));
    if (!enabled || sourceImage == null || buffer == null) {
        println(">>> Sortie anticipée !"); 
        return;
    }
    println("=== ça commencegggggggg ===");
  println("enabled: " + enabled);
  println("sourceImage: " + (sourceImage == null ? "NULL" : "OK"));
  println("bass: " + bass + " | mid: " + mid + " | treble: " + treble);
    if (!enabled || sourceImage == null) return;

    buffer.beginDraw();
    buffer.background(0);
    
    // Copie l'image de fond dans le buffer
    buffer.image(sourceImage, 0, 0);
    
    buffer.loadPixels();

    // Glitch 1: Pixel shift (bass)
    int intensity = int(bass * 50.0);
    for (int i = 0; i < intensity; i++) {
      int x = int(random(buffer.width));
      int y = int(random(buffer.height));
      int idx = x + y * buffer.width;
      if (idx < buffer.pixels.length - 1) {
        buffer.pixels[idx] = buffer.pixels[idx + 1];
      }
    }

    // Glitch 2: Color shift (mid)
    float shift = mid * 20.0;
    for (int i = 0; i < buffer.pixels.length; i++) {
      color c = buffer.pixels[i];
      float r = red(c);
      float g = green(c);
      float b = blue(c);
      buffer.pixels[i] = color((r + shift) % 255.0, g, b);
    }

    // Glitch 3: Block displacement (treble)
    int blockSize = 16;
    int numBlocks = int(treble * 10.0);
    for (int i = 0; i < numBlocks; i++) {
      int bx = int(random(buffer.width / blockSize)) * blockSize;
      int by = int(random(buffer.height / blockSize)) * blockSize;
      int offsetX = int(random(-20.0, 20.0));
      int offsetY = int(random(-20.0, 20.0));

      for (int y = 0; y < blockSize; y++) {
        for (int x = 0; x < blockSize; x++) {
          int srcX = constrain(bx + x, 0, buffer.width - 1);
          int srcY = constrain(by + y, 0, buffer.height - 1);
          int destX = constrain(bx + x + offsetX, 0, buffer.width - 1);
          int destY = constrain(by + y + offsetY, 0, buffer.height - 1);

          int srcIdx = srcX + srcY * buffer.width;
          int destIdx = destX + destY * buffer.width;

          if (srcIdx < buffer.pixels.length && destIdx < buffer.pixels.length) {
            buffer.pixels[destIdx] = buffer.pixels[srcIdx];
          }
        }
      }
    }

    buffer.updatePixels();
    buffer.endDraw();

    //  Remplace l'image de fond par la version glitchée
    image(buffer, 0, 0);
  }

  void toggle() {
    enabled = !enabled;
    println("Datamosh: " + (enabled ? "ON" : "OFF"));
  }
}
